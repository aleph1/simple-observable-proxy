/*! simple observable proxy v2.0.0 | MIT License | © 2022 Aleph1 Technologies Inc */
const e={change:"change",destroy:"destroy"},r=new Set,t=new Map,n=new Map,o=new Set,a=new Set,s={}.constructor,c=()=>{o.forEach((e=>{const r=n.get(e);r&&r.change.forEach((e=>e()))})),o.clear(),a.forEach((e=>{const r=n.get(e);r&&r.destroy.forEach((e=>e()))})),a.clear(),"undefined"!=typeof window&&window.requestAnimationFrame?window.requestAnimationFrame(c):setTimeout(c,16)},d=(e,a)=>{if(r.has(e))throw new Error("data is alreaby an observable");if(a&&!t.has(a))throw new Error("rootProxy isn’t an observable");let c;const i=new Proxy(e,{get:(e,r)=>e[r],set(e,r,n){if(e[r]!==n){if(c){if(t.has(n))throw new Error("Can’t nest observables");o.add(a||i)}e[r]=n}return!0},deleteProperty:(e,r)=>r in e&&(delete e[r],o.add(a||i),!0)});return r.add(e),t.set(i,e),(Array.isArray(e)?[...Array(e.length).keys()]:Object.keys(e)).forEach((r=>{const n=e[r];if(t.has(n))throw new Error("Can’t nest observables");(e=>Array.isArray(e)||(e=>!!e&&"object"==typeof e&&e.constructor===s)(e))(n)&&(i[r]=d(n,a||i))})),n.set(i,c={change:new Set,destroy:new Set}),i},i=e=>{if((e=>Array.isArray(e)||(e=>!!e&&"object"==typeof e&&e.constructor===s)(e))(e))return d(e);throw new Error("Only Arrays and plain Objects are observable")},y=(e,r,t)=>{const o=n.get(e);return!(!o||!o[r]||"function"!=typeof t||o[r].has(t))&&(o[r].add(t),!0)},w=(e,r,t)=>{const o=n.get(e);return!(!o||!o[r]||"function"!=typeof t)&&o[r].delete(t)},h=(r,t)=>y(r,e.change,t),l=(r,t)=>w(r,e.change,t),f=e=>{const a=n.get(e);return!!a&&(a.change.clear(),a.destroy.clear(),r.delete(t.get(e)),t.delete(e),n.delete(e),o.delete(e),!0)};c();export{e as ObservableEvents,f as destroy,i as observable,h as observe,w as off,y as on,l as unobserve};

/*! simple observable proxy v2.0.0 | MIT License | © 2022 Aleph1 Technologies Inc */
const e={change:"change",destroy:"destroy"},r=new Set,t=new Map,n=new Map,o=new Set,a=new Set,s={}.constructor,c=()=>{o.forEach((e=>{const r=n.get(e);r&&r.change.forEach((e=>e()))})),o.clear(),a.forEach((e=>{const r=n.get(e);r&&r.destroy.forEach((e=>e()))})),a.clear(),window.requestAnimationFrame(c)},y=(e,a)=>{if(r.has(e))throw new Error("data is alreaby an observable");if(a&&!t.has(a))throw new Error("rootProxy isn’t an observable");let c;const d=new Proxy(e,{get:(e,r)=>e[r],set(e,r,n){if(e[r]!==n){if(c){if(t.has(n))throw new Error("Can’t nest observables");o.add(a||d)}e[r]=n}return!0},deleteProperty:(e,r)=>r in e&&(delete e[r],o.add(a||d),!0)});return r.add(e),t.set(d,e),(Array.isArray(e)?[...Array(e.length).keys()]:Object.keys(e)).forEach((r=>{const n=e[r];if(t.has(n))throw new Error("Can’t nest observables");(e=>Array.isArray(e)||(e=>!!e&&"object"==typeof e&&e.constructor===s)(e))(n)&&(d[r]=y(n,a||d))})),n.set(d,c={change:new Set,destroy:new Set}),d},d=e=>{if((e=>Array.isArray(e)||(e=>!!e&&"object"==typeof e&&e.constructor===s)(e))(e))return y(e);throw new Error("Only Arrays and plain Objects are observable")},h=(e,r,t)=>{const o=n.get(e);return!(!o||!o[r]||"function"!=typeof t||o[r].has(t))&&(o[r].add(t),!0)},l=(e,r,t)=>{const o=n.get(e);return!(!o||!o[r]||"function"!=typeof t)&&o[r].delete(t)},w=(r,t)=>h(r,e.change,t),i=(r,t)=>l(r,e.change,t),f=e=>{const a=n.get(e);return!!a&&(a.change.clear(),a.destroy.clear(),r.delete(t.get(e)),t.delete(e),n.delete(e),o.delete(e),!0)};c();export{e as ObservableEvents,f as destroy,d as observable,w as observe,l as off,h as on,i as unobserve};

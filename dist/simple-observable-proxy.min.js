/*! simple observable proxy v1.0.0 | MIT License | © 2022 Aleph1 Technologies Inc */
const e=new Set,r=new Map,t=new Map,o=new Set,n={}.constructor,a=()=>{o.forEach((e=>{t.get(e).forEach((e=>e()))})),o.clear(),window.requestAnimationFrame(a)},s=(a,c)=>{if(e.has(a))throw new Error("Can’t observe Object or Array again");if(r.has(a))throw new Error("rootProxy isn’t an observable");let i;const y=new Proxy(a,{get:(e,r)=>e[r],set(e,t,n){if(e[t]!==n){if(i){if(r.has(n))throw new Error("Can’t nest observables");o.add(c||y)}e[t]=n}return!0},deleteProperty:(e,r)=>r in e&&(delete e[r],o.add(c||y),!0)});return(Array.isArray(a)?[...Array(a.length).keys()]:Object.keys(a)).forEach((e=>{const t=a[e];if(r.has(t))throw new Error("Can’t nest observables");(e=>!!e&&(Array.isArray(e)||"object"==typeof e&&e.constructor===n))(t)&&(y[e]=s(t,c||y))})),i=new Set,e.add(a),r.set(y,a),t.set(y,i),y},c=e=>(e=>!!e&&(Array.isArray(e)||"object"==typeof e&&e.constructor===n))(e)&&s(e),i=(e,r)=>{const o=t.get(e);return!(!o||"function"!=typeof r)&&o.add(r)},y=(e,r)=>{const o=t.get(e);return!(!o||"function"!=typeof r)&&o.delete(r)},d=n=>{const a=t.get(n);return!!a&&(a.clear(),e.delete(r.get(n)),r.delete(n),t.delete(n),o.delete(n),!0)};a();export{d as destroy,c as observable,i as observe,y as unobserve};

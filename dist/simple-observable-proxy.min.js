/*! simple observable proxy v2.0.0 | MIT License | © 2022 Aleph1 Technologies Inc */
const e=new Set,r=new Map,t=new Map,n=new Set,o={}.constructor,a=()=>{n.forEach((e=>{t.get(e).forEach((e=>e()))})),n.clear(),"undefined"!=typeof window&&window.requestAnimationFrame?window.requestAnimationFrame(a):setTimeout(a,16)},s=(a,i)=>{if(e.has(a))throw new Error("Only Arrays and plain Objects are observable");if(r.has(a))throw new Error("rootProxy isn’t an observable");let c;const d=new Proxy(a,{get:(e,r)=>e[r],set(e,t,o){if(e[t]!==o){if(c){if(r.has(o))throw new Error("Can’t nest observables");n.add(i||d)}e[t]=o}return!0},deleteProperty:(e,r)=>r in e&&(delete e[r],n.add(i||d),!0)});return(Array.isArray(a)?[...Array(a.length).keys()]:Object.keys(a)).forEach((e=>{const t=a[e];if(r.has(t))throw new Error("Can’t nest observables");(e=>Array.isArray(e)||(e=>!!e&&"object"==typeof e&&e.constructor===o)(e))(t)&&(d[e]=s(t,i||d))})),c=new Set,e.add(a),r.set(d,a),t.set(d,c),d},i=e=>{if((e=>Array.isArray(e)||(e=>!!e&&"object"==typeof e&&e.constructor===o)(e))(e))return s(e);throw new Error("Only Arrays and plain Objects are observable")},c=(e,r)=>{const n=t.get(e);return!(!n||"function"!=typeof r)&&n.add(r)},d=(e,r)=>{const n=t.get(e);return!(!n||"function"!=typeof r)&&n.delete(r)},w=o=>{const a=t.get(o);return!!a&&(a.clear(),e.delete(r.get(o)),r.delete(o),t.delete(o),n.delete(o),!0)};a();export{w as destroy,i as observable,c as observe,d as unobserve};

/*! simple observable proxy v2.0.0 | MIT License | © 2022 Aleph1 Technologies Inc */
const e={change:"change",destroy:"destroy"},r=new Set,t=new Map,n=new Map,o=new Set,a=new Set,s={}.constructor,c=()=>{o.forEach((e=>{const r=n.get(e);r&&r.change.forEach((e=>e()))})),o.clear(),a.forEach((e=>{const r=n.get(e);r&&r.destroy.forEach((e=>e()))})),a.clear(),"undefined"!=typeof window&&window.requestAnimationFrame?window.requestAnimationFrame(c):setTimeout(c,16)},d=(e,a)=>{if(r.has(e))throw new Error("Only Arrays and plain Objects are observable");if(t.has(e))throw new Error("rootProxy isn’t an observable");let c;const y=new Proxy(e,{get:(e,r)=>e[r],set(e,r,n){if(e[r]!==n){if(c){if(t.has(n))throw new Error("Can’t nest observables");o.add(a||y)}e[r]=n}return!0},deleteProperty:(e,r)=>r in e&&(delete e[r],o.add(a||y),!0)});return(Array.isArray(e)?[...Array(e.length).keys()]:Object.keys(e)).forEach((r=>{const n=e[r];if(t.has(n))throw new Error("Can’t nest observables");(e=>Array.isArray(e)||(e=>!!e&&"object"==typeof e&&e.constructor===s)(e))(n)&&(y[r]=d(n,a||y))})),r.add(e),t.set(y,e),n.set(y,c={change:new Set,destroy:new Set}),y},y=e=>{if((e=>Array.isArray(e)||(e=>!!e&&"object"==typeof e&&e.constructor===s)(e))(e))return d(e);throw new Error("Only Arrays and plain Objects are observable")},i=(e,r,t)=>{const o=n.get(e);return!(!o||!o[r]||"function"!=typeof t||o[r].has(t))&&(o[r].add(t),!0)},w=(e,r,t)=>{const o=n.get(e);return!(!o||!o[r]||"function"!=typeof t)&&o[r].delete(t)},h=(r,t)=>i(r,e.change,t),l=(r,t)=>w(r,e.change,t),f=e=>{const a=n.get(e);return!!a&&(a.change.clear(),a.destroy.clear(),r.delete(t.get(e)),t.delete(e),n.delete(e),o.delete(e),!0)};c();export{e as ObservableEvents,f as destroy,y as observable,h as observe,w as off,i as on,l as unobserve};

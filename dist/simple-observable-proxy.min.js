/*! simple observable proxy v1.1.0 | MIT License | © 2022 Aleph1 Technologies Inc */
const e=new Set,r=new Map,t=new Map,o=new Set,n={}.constructor,a=()=>{o.forEach((e=>{t.get(e).forEach((e=>e()))})),o.clear(),"undefined"!=typeof window&&window.requestAnimationFrame?window.requestAnimationFrame(a):setTimeout(a,16)},s=(a,c)=>{if(e.has(a))throw new Error("Can’t observe Object or Array again");if(r.has(a))throw new Error("rootProxy isn’t an observable");let i;const d=new Proxy(a,{get:(e,r)=>e[r],set(e,t,n){if(e[t]!==n){if(i){if(r.has(n))throw new Error("Can’t nest observables");o.add(c||d)}e[t]=n}return!0},deleteProperty:(e,r)=>r in e&&(delete e[r],o.add(c||d),!0)});return(Array.isArray(a)?[...Array(a.length).keys()]:Object.keys(a)).forEach((e=>{const t=a[e];if(r.has(t))throw new Error("Can’t nest observables");(e=>Array.isArray(e)||(e=>!!e&&"object"==typeof e&&e.constructor===n)(e))(t)&&(d[e]=s(t,c||d))})),i=new Set,e.add(a),r.set(d,a),t.set(d,i),d},c=e=>(e=>Array.isArray(e)||(e=>!!e&&"object"==typeof e&&e.constructor===n)(e))(e)&&s(e),i=(e,r)=>{const o=t.get(e);return!(!o||"function"!=typeof r)&&o.add(r)},d=(e,r)=>{const o=t.get(e);return!(!o||"function"!=typeof r)&&o.delete(r)},w=n=>{const a=t.get(n);return!!a&&(a.clear(),e.delete(r.get(n)),r.delete(n),t.delete(n),o.delete(n),!0)};a();export{w as destroy,c as observable,i as observe,d as unobserve};

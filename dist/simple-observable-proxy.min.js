/*! simple observable proxy v3.0.0 | MIT License | © 2022 Aleph1 Technologies Inc */
const e={change:"change",destroy:"destroy"},r=new Set,t=new Map,a=new Map,n=new Set,o=new Set,s={}.constructor,c=e=>!!e&&"object"==typeof e&&e.constructor===s,d=()=>{n.forEach((e=>{const r=a.get(e);r&&r.change.forEach((r=>r(e)))})),n.clear(),o.forEach((e=>{const r=a.get(e);r&&(r.destroy.forEach((r=>r(e))),r.change.clear(),r.destroy.clear(),t.delete(e),a.delete(e))})),o.clear(),window.requestAnimationFrame(d)},i=(e,o)=>{if(r.has(e)||t.has(e))throw new Error("data is already an observable");let s;const d=new Proxy(e,{get:(e,r)=>e[r],set(e,r,a){if(e[r]!==a){if(s){if(t.has(a))throw new Error("Can’t nest observables");n.add(o||d)}e[r]=a}return!0},deleteProperty:(e,r)=>(r in e&&(delete e[r],n.add(o||d)),!0)});return r.add(e),t.set(d,e),(Array.isArray(e)?[...Array(e.length).keys()]:Object.keys(e)).forEach((r=>{const a=e[r];if(t.has(a))throw new Error("Can’t nest observables");Array.isArray(a)||c(a)?d[r]=i(a,o||d):a instanceof Map&&(d[r]=h(a,o||d))})),a.set(d,s={change:new Set,destroy:new Set}),d},h=(e,o)=>{if(r.has(e)||t.has(e))throw new Error("data is already an observable");let s;const d=new Proxy(e,{get(e,r){const a=e[r];return"function"==typeof a?"set"===r?(a,c)=>{if(s){if(t.has(c))throw new Error("Can’t nest observables");const r=e.has(a);(!r||r&&e.get(a)!==c)&&n.add(o||d)}return e[r](a,c)}:"clear"===r?()=>(e.size&&n.add(o||d),e[r]()):"delete"===r?t=>(e.has(t)&&n.add(o||d),e[r](t)):a.bind(e):a}});return r.add(e),t.set(d,e),e.forEach(((e,r)=>{if(t.has(e))throw new Error("Can’t nest observables");Array.isArray(e)||c(e)?d.set(r,i(e,o||d)):e instanceof Map&&d.set(r,h(e,o||d))})),a.set(d,s={change:new Set,destroy:new Set}),d},w=e=>{if(Array.isArray(e))return i(e);if(c(e))return i(e);if(e instanceof Map)return h(e);throw new Error("data must be plain Object, Array, or Map")},f=e=>t.has(e),y=e=>{if(c(e))return i(e);throw new Error("data must be a plain Object")},l=e=>{if(Array.isArray(e))return i(e);throw new Error("data must be an Array")},u=e=>{if(e instanceof Map)return h(e);throw new Error("data must be a Map")},b=(e,r,t)=>{const n=a.get(e);return!(!n||!n[r]||"function"!=typeof t||n[r].has(t))&&(n[r].add(t),!0)},g=(e,r,t)=>{const n=a.get(e);return!(!n||!n[r]||"function"!=typeof t)&&n[r].delete(t)},p=e=>!!a.get(e)&&(o.add(e),r.delete(t.get(e)),!0);d();export{e as ObservableEvents,p as destroy,f as isObservable,c as isPlainObject,w as observable,l as observableArray,u as observableMap,y as observableObject,g as off,b as on};

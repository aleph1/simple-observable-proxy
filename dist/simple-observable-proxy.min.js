/*! simple observable proxy v2.0.0 | MIT License | © 2022 Aleph1 Technologies Inc */
const e={change:"change",destroy:"destroy"},r=new Set,t=new Map,a=new Map,n=new Set,o=new Set,s={}.constructor,c=()=>{n.forEach((e=>{const r=a.get(e);r&&r.change.forEach((r=>r(e)))})),n.clear(),o.forEach((e=>{const r=a.get(e);r&&(r.destroy.forEach((r=>r(e))),r.change.clear(),r.destroy.clear(),t.delete(e),a.delete(e))})),o.clear(),window.requestAnimationFrame(c)},d=(e,o)=>{if(r.has(e)||t.has(e))throw new Error("data is alreaby an observable");let c;const y=new Proxy(e,{get:(e,r)=>e[r],set(e,r,a){if(e[r]!==a){if(c){if(t.has(a))throw new Error("Can’t nest observables");n.add(o||y)}e[r]=a}return!0},deleteProperty:(e,r)=>(r in e&&(delete e[r],n.add(o||y)),!0)});return r.add(e),t.set(y,e),(Array.isArray(e)?[...Array(e.length).keys()]:Object.keys(e)).forEach((r=>{const a=e[r];if(t.has(a))throw new Error("Can’t nest observables");(e=>Array.isArray(e)||(e=>!!e&&"object"==typeof e&&e.constructor===s)(e))(a)&&(y[r]=d(a,o||y))})),a.set(y,c={change:new Set,destroy:new Set}),y},y=e=>{if((e=>Array.isArray(e)||(e=>!!e&&"object"==typeof e&&e.constructor===s)(e))(e))return d(e);throw new Error("Only Arrays and plain Objects are observable")},h=(e,r,t)=>{const n=a.get(e);return!(!n||!n[r]||"function"!=typeof t||n[r].has(t))&&(n[r].add(t),!0)},l=(e,r,t)=>{const n=a.get(e);return!(!n||!n[r]||"function"!=typeof t)&&n[r].delete(t)},w=(r,t)=>h(r,e.change,t),f=(r,t)=>l(r,e.change,t),i=e=>!!a.get(e)&&(o.add(e),r.delete(t.get(e)),!0);c();export{e as ObservableEvents,i as destroy,y as observable,w as observe,l as off,h as on,f as unobserve};

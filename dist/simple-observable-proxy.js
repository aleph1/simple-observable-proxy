const e=new Set,t=new Map,r=new Map,o=new Set,n={}.constructor,s=()=>{o.forEach((e=>{r.get(e).forEach((e=>e()))})),o.clear(),window.requestAnimationFrame(s)},a=(s,c)=>{if(e.has(s))throw new Error("Can’t observe Object or Array again");const d=new Proxy(s,{get:(e,t)=>e[t],set(e,r,n){if(e[r]!==n){if(y){if(t.has(n))throw new Error("Can’t nest observables");o.add(c||d)}e[r]=n}return!0},deleteProperty:(e,t)=>t in e&&(delete e[t],o.add(c||d),!0)});(Array.isArray(s)?[...Array(s.length).keys()]:Object.keys(s)).forEach((e=>{const r=s[e];if(t.has(r))throw new Error("Can’t nest observables");(e=>!!e&&(Array.isArray(e)||"object"==typeof e&&e.constructor===n))(r)&&(d[e]=a(r,c||d))}));const y=new Set;return e.add(s),t.set(d,s),r.set(d,y),d};export const observable=e=>(e=>!!e&&(Array.isArray(e)||"object"==typeof e&&e.constructor===n))(e)&&a(e);export const observe=(e,t)=>{const o=r.get(e);return!(!o||"function"!=typeof t)&&o.add(t)};export const unobserve=(e,t)=>{const o=r.get(e);return!(!o||"function"!=typeof t)&&o.delete(t)};export const destroy=n=>{const s=r.get(n);return!!s&&(s.clear(),e.delete(t.get(n)),t.delete(n),r.delete(n),o.delete(n),!0)};s();
const e=new WeakSet,r=new WeakMap,o=new Set;export class Observable{constructor(t,s){if(e.has(t))throw new Error("Already observing source");let n=!1;const b=this,a=new Proxy(t,{get:(e,r)=>e[r],set(e,t,a){if(e[t]!==a){if(n){if(r.has(a))throw new Error("Can’t nest observables");o.add(s||b)}e[t]=a}return!0},deleteProperty:(e,r)=>r in e&&(delete e[r],o.add(s||b),!0)});(Array.isArray(t)?t.keys():Object.keys(t)).forEach((e=>{const o=t[e];if(r.has(o))throw new Error("Can’t nest observables");(Array.isArray(o)||"object"==typeof o&&o instanceof Object)&&(a[e]=new Observable(o,b).proxy)})),this.observers=new Set,r.set(this.proxy=a,this),e.add(this.source=t),n=!0}observe(e){return this.observers.add(e)}unobserve(e){return this.observers.delete(e)}destroy(){this.observers.clear(),this.observers=null,e.delete(this.source),r.delete(this.proxy)}}export function observable(e){return new Observable(e).proxy}export function observe(e,o){const t=r.get(e);if(!t)throw new Error("observableProxy not observable");return t.observe(o)}export function unobserve(e,o){const t=r.get(e);if(!t)throw new Error("observableProxy not observable");return t.unobserve(o)}export function destroy(e){const o=r.get(e);if(!o)throw new Error("observableProxy not observable");return o.destroy()}!function e(){o.forEach((e=>{e.observers.forEach((e=>e()))})),o.clear(),window.requestAnimationFrame(e)}();
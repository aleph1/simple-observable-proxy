const e=new Set,t=new Map,r=new Map,o=new Set,n=()=>{o.forEach((e=>{r.get(e).forEach((e=>e()))})),o.clear(),window.requestAnimationFrame(n)},s=(n,a)=>{if(e.has(n))throw new Error("Proxy of data already exists");let c=!1;new Set;const d=new Proxy(n,{get:(e,t)=>e[t],set(e,r,n){if(e[r]!==n){if(c){if(t.has(n))throw new Error("Can’t nest observables");o.add(a||d)}e[r]=n}return!0},deleteProperty:(e,t)=>t in e&&(delete e[t],o.add(a||d),!0)});return(Array.isArray(n)?[...Array(n.length).keys()]:Object.keys(n)).forEach((e=>{const r=n[e];if(t.has(r))throw new Error("Can’t nest observables");(Array.isArray(r)||"object"==typeof r&&r instanceof Object)&&(d[e]=s(r,a||d))})),c=!0,e.add(n),t.set(d,n),r.set(d,new Set),d};export const observable=e=>(Array.isArray(e)||"object"==typeof e&&e instanceof Object)&&s(e);export const observe=(e,t)=>{const o=r.get(e);return!(!o||"function"!=typeof t)&&o.add(t)};export const unobserve=(e,t)=>{const o=r.get(e);return!(!o||"function"!=typeof t)&&o.delete(t)};export const destroy=n=>{const s=r.get(n);return!!s&&(s.clear(),e.delete(t.get(n)),t.delete(n),r.delete(n),o.delete(n),!0)};n();